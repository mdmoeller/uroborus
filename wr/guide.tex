\documentclass[english]{article}

\usepackage[latin9]{inputenc}
\usepackage[letterpaper]{geometry}
\geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{cite}

% Typeset UROBORUS:
\newcommand{\Uro}{\textsc{Uroborus}}
\newcommand{\Taran}{\textsc{Tarantula}}

% The `example' files referred to by this text:
\newcommand{\fc}{\texttt{faultycode}}
\newcommand{\fcp}{\texttt{faultycode.py}}
\newcommand{\fcT}{\texttt{faultycodeTest.py}}
\newcommand{\fcip}{\texttt{faultycode\_instrumented.py}}
\newcommand{\fcc}{\texttt{faultycode\_coverage.txt}}
\newcommand{\fcpf}{\texttt{faultycode\_passfail.txt}}
\newcommand{\fch}{\texttt{faultycode\_report.html}}



\title{Fault Localization with Uroborus}
\author{Samarth Kishore \and Daniel Klein \and Mark Moeller \and Twisha Shah \and
\{samarthk, kleindan, mmoeller, twisha\}@seas.upenn.edu}



\begin{document}
\maketitle


\section{Introduction}

\Uro\ is a fault localization tool for Python built in the style of Jones, Harrold and Stasko's
\Taran ~\cite{Jones}.

Suppose we have written a Python module \fcp\ that we we want to debug with the
help of \Uro. At a high level, we need to do the following:
\begin{enumerate}
\item We write a set of \Uro\ tests for \fc\ that call the methods of the module we want to test.
\item We run the \Uro\ on the test module, which generates datafiles detailing statement coverage and assertion
passes and failures.
\item \Uro\ generates a ``report,'' which is an HTML file representing the source code, colored according
to the pass/failure calculations in the style of \Taran.
\end{enumerate}
\textbf{Note:} At this time, \Uro\ is only able to test the \emph{methods} of an
input source file. That is, scripts are not handled under the current framework, but are an area being
considered for further improvement of the tool.

%%\section{Instrumenting a Source File}

%%To instrument a source file called \fcp, we just need to run the command:\\

%%\texttt{\$ instrument.py }\fcp\ \\

%%This will produce a file called \fcip\  which is the instrumented version of the source.

\section{Creating \Uro\ Test Modules}

A developer first needs to create \Uro-style tests for \fc. To do that, we just have to write a
module, say \fcT, that has the following header:\\
\begin{verbatim}
#!/usr/bin/python
import urotest

faultycode = urotest.uro_import('faultycode')
\end{verbatim}

From there, the test suite consists of \emph{methods} which are tests of the desired methods of \fc. 
That is, the script need not do anything when run directly. In particular, the test module \emph{should
not} call any methods of instrumented code if run directly. 
Each method of the test suite should take one parameter, and that parameter is the
\texttt{RuntimeOracle} that will be used for that test case.

The developer may optionally include a method called \texttt{init} if some intial set up is
required. \Uro\ will run \texttt{init} if it exists before any other tests in the module.

Note that \emph{any} methods at the package level in \fcT\ will be
assumed to be an \Uro\ test that takes a RuntimeOracle as an argument.
If a helper method is required for one or more test methods, it should
be encapsulated within a class in \fcT\ so that it is not run directly
as an \Uro\ test.

\section{Localizing Faults}

Next, the developer runs the tests. This is done with:\\
 
\texttt{\$ uroborus }\fcT \\

The module-level methods will each be
run in turn by \Uro, very similarly to how JUnit runs a set of methods. Order of execution of these
methods is not defined.

All assertions must be
done with \texttt{RuntimeOracle}'s assertion methods (for details, see the documentation for RuntimeOracle).

When the tests are run, \Uro\
will generate \fcc\ and \fcpf, and it will write information to standard out about the tests that
pass and fail. 

Finally, \Uro\ generates the HTML report. It will output a file called \fch. This file is
the fault-visualized version of the source code.


\bibliographystyle{plain}
\bibliography{BibEntries}
\end{document}
