\documentclass[english]{article}

\usepackage[latin9]{inputenc}
\usepackage[letterpaper]{geometry}
\geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
\usepackage{amsmath}
\usepackage{amssymb}


% Typeset UROBORUS:
\newcommand{\Uro}{\textsc{Uroborus}}
\newcommand{\Taran}{\textsc{Tarantula}}

% The `example' files referred to by this text:
\newcommand{\fc}{\texttt{faultycode}}
\newcommand{\fcp}{\texttt{faultycode.py}}
\newcommand{\fcT}{\texttt{faultycodeTest.py}}
\newcommand{\fcip}{\texttt{faultycode_instrumented.py}}
\newcommand{\fcc}{\texttt{faultycode_coverage.txt}}
\newcommand{\fcpf}{\texttt{faultycode_passfail.txt}}
\newcommand{\fch}{\texttt{faultycode_report.html}}



\title{Fault Localization with Uroborus}
\author{Samarth Kishore
    %%samarthk@seas.upenn.edu
\and 
Dan Klein
    %%kleindan@seas.upenn.edu
\and 
Mark Moeller
    %%mmoeller@seas.upenn.edu
\and 
Twisha Shah
    %%twisha@seas.upenn.edu
}



\begin{document}
\maketitle


\section{Introduction}

\Uro\ is a fault localization tool for Python built in the style of Jones, Harrold and Stasko's
\Taran [citation]. 

Suppose we have written a Python module \fcp\ that we we want to debug with the
help of \Uro. At a high level, we need to do the following:
\begin{enumerate}
\item We instrument the input source file, \fcp.
\item We write a set of \Uro\ tests for \fc\ that call the methods of the instrumented source, in the
form of a script.
\item We run the test script, which generates datafiles detailing statement coverage and assertion
passes and failures.
\item We generate a `report,' which is an HTML file representing the source code, colored according
to the pass/failure calculations defined by \Taran.
\end{enumerate}
\textbf{Note:} At this time, \Uro\ is only able to test the \emph{functions} of an
input source file. Scripts are not handled under the current framework, but are an area being
considered for further improvement of the tool.

\section{Instrumenting a Source File}

To instrument a source file called \fcp, we just need to run the command:\\
\texttt{\$ instrument.py }\fcp

This will produce a file called \fcip, which is the instrumented version of the source.

\section{Creating Test Scripts}

A developer then needs to create \Uro-style tests for \fc. To do that, we just have to write a
script, call it \fcT, that has the following header:\\
\begin{verbatim}
#!/usr/bin/python

import faultycode_instrumented as faultycode

from RuntimeOracle import RuntimeOracle

R = RuntimeOracle("faultycode_passfail.txt")
faultycode.R = R
\end{verbatim}

From there, the script is written to test the desired methods of \fc. All assertion checking must be
done with \texttt{RuntimeOracle}'s assertion methods (for details, see the documentation for RuntimeOracle).

This is a little bit messy for the developer. Improvements to this requirement are another area of
improvement being considered for \Uro.

\section{Localizing Faults}

All that remains is for the developer to run the test script. When the test script is run, \Uro\
will generate \fcc\ and \fcpf. Finally, we generate the visualization with:\\
\texttt{\$ generate\_report.py }\fcp

This command will automatically find the datafiles it needs (assuming they have been properly
generated) and it will output a file called \fch, which is the original source visualized in HTML
according to the specifications of \Taran.

\end{document}
